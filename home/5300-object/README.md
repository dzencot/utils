В некоторых ситуациях, мы хотим ограничить входной параметр функции типом "любой объект". Например, для функции проверяющей наличие ключей в объекте. Существует несколько способов сделать такую проверку и не все из них работают так как ожидается. Посмотрите на пример:

```typescript
// В качестве типа используется {}
function toString(obj: {}) {
  return obj.toString();
}

toString('wow'); // Ok!
toString(123); // Ok!
toString({}); // Ok!
```

Пустой объектный тип `{}` подразумевает под собой объект любой структуры и ограничивает множество всех значений, за исключением `null` и `undefined`. Пустой интерфейс работает также как и пустой объектный тип. Это вряд ли то, что мы ожидали.

Тип `Object` — это тип объекта и работает так же, как тип `{}` с некоторыми отличиями. Он предопределяет типы некоторых встроенных методов, например, `toString()`, а тип `{}` этого не делает. Например:

```typescript
const foo: {} = {
  toString() {
    return 1; // Ok!
  }
};

const bar: Object = {
  toString() {
    return 1; // Error!
  }
};
```

Второе определение `bar` не работает, потому что тип `Object` указывает на то, что метод `toString()` должен возвращать строку.

Если мы хотим работать с не примитивными значениями, то для этого существует еще один тип `object` (с маленькой буквы):

```typescript
function toString(obj: object) {
  return obj.toString();
}

foo('wow'); // Error!
foo(123); // Error!
foo({}); // Ok!
```

С помощью типа `object` нельзя получить доступ к свойствам объекта, для такой задачи используются уже другие механизмы.
