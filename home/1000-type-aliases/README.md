Представим программу, в которой есть объект пользователя. Этот объект используется повсеместно. В такой ситуации описание типа этого объекта будет повторяться в каждом определении функции. Во-первых, здесь много дублирования. Во-вторых, значительно усложняется изменение структуры, так как придется руками править все места, где встречается это определение. В этом уроке разберем, как избежать таких проблем.

[//]: # ( TODO - автору: во-первых и во-вторых - это перечисление минусов? не совсем ясно, о чем речь - что характеризуем? Где много дублирования, где или почему усложняется изменение структуры? )

## Задаем алиас типа

Чтобы не делать одну и ту же работу, да еще и руками, TypeScript позволяет задавать имя, алиас или псевдоним для составных типов. Так мы не будем повторяться:

[//]: # ( TODO - автору: имя, алиас и псевдоним - это одно и то же? Просто не сказали об этом. Нужно сразу это обозначить. Студент должен понимать, что может столкнуться с разными названиями )

```javascript
type User = {
  firstName: string;
  pointsCount: number;
}
```

Теперь можно провести замену во всех функциях:


```typescript
function doSomething(user: User) {
  // ...
}
```

Алиас — это не создание нового типа данных. Это способ сокращенно записать определение типа. Поэтому следующие примеры будут работать без проблем:

```typescript
const user = {
  firstName: 'Mike',
  pointsCount: 1000,
};

// Оба вызова работают
doSomething(user);
doSomething({ firstName: 'Bob', pointsCount: 1800 });
```

При этом разработчики на TypeScript говорят «создал тип», а не «создал алиас типа» или «создал псевдоним типа». Поэтому в этом курсе мы будем придерживаться общепринятого формата.

Типы можно задавать для любых типов данных, например, для простых:

```typescript
type SomeType = string;
```

А также для составных:

```typescript
// union тип из трех возможных значений
type SomeType = string | number | null;

// Функция
type Countable = (coll: number[]) => number
```

## Объекты и функции

Описание типа функции вне объекта и внутри отличается. Когда функция записывается самостоятельно, то используется формат стрелочной функции:

```typescript
type Countable = (coll: number[]) => number
```

Внутри типа, который описывает объект, формат меняется на используемый для обычных свойств:

```typescript
type User = {
  firstName: string;
  pointsCount: number;
  count(coll: number[]): number;
}
```

Но это не касается колбеков, которые могут быть использованы внутри:

```typescript
type User = {
  firstName: string;
  pointsCount: number;
  // Типы взяты для примера
  count(coll: (v: string) => string): number;
}
```
